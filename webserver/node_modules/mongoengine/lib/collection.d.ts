import { Collection as Document, InsertOneWriteOpResult } from 'mongodb';
import { ICollection } from './interfaces/icollection';
import { IEngine } from './interfaces/iengine';
import { IEnvelope } from './interfaces/ienvelope';
import { Results } from './result';
/**
 * Represents a mongodb collection of documents i.e. namepsace
 * where unique identifiable documents records are collated
 */
export declare abstract class Collection implements ICollection {
    readonly CollectionName: string;
    ClassReference: (new () => any) | undefined;
    private query;
    private $client;
    private $database;
    private $collection;
    /**
     * If the payload exists then the functions will retrieve the correct values automatically
     * so remember to leverage this functionality without worrying about implementing complex lookup
     * patterns
     */
    engine: IEngine;
    envelope: IEnvelope;
    init(): Promise<void>;
    static $eq: <T extends Collection>(this: new (args?: any[] | undefined) => T, key: string, value: any) => Collection;
    static $gte: <T extends Collection>(this: new (args?: any[] | undefined) => T, key: string, value: any) => Collection;
    static $lte: <T extends Collection>(this: new (args?: any[] | undefined) => T, key: string, value: any) => Collection;
    static find: <T extends Collection>(this: new (args?: any[] | undefined) => T, query?: {} | undefined) => Promise<Results<T> | null>;
    static delete: <T extends Collection>(this: new (args?: any[] | undefined) => T, query?: {} | undefined) => Promise<number>;
    $elemMatch(key: string, value: any): this;
    getO(path: string, value: any): {
        name: string;
    };
    $eq(key: string, value: any): this;
    $gt(key: string, value: any): any;
    $gte(key: string, value: any): this;
    $lt(key: string, value: any): this;
    $lte(key: string, value: any): any;
    /**
     * Check that all fields marked as required are not empty otherwise raise an error. This
     * method should be called before save is issued.
     */
    private checkRequired;
    /**
     * Flush the data that has changed to the database
     */
    commit(): Promise<void>;
    delete(query: {}, callback?: (matchedDocuments: Array<Document> | Error) => {}): Promise<number>;
    static deleteMany(): Promise<number>;
    static deleteOne(query: {
        [field: string]: number;
    }): Promise<number>;
    /**
     * Checks if the key exists on this document and if does then all is well otherwise throws
     * an error
     */
    exists(key: string): boolean;
    /**
     *
     * @param query
     */
    existsDeep(key: string): boolean;
    /**
     * Find a document from this collection using a JS object as input for value lookup
     * and query matching
     *
     * @param query Javascript object representation to use for query parameters passed to mongodb
     *
     * @returns An iterable cursor instance of mongoengine.cursors.Cursor
     */
    find<T extends Collection>(query?: {}): Promise<Results<T> | null>;
    /**
     * Retrieve `n` amount of documents from the mongodb backend server - where n = limit
     *
     * @param limit (optional) The number of documents to fetch from the mongodb connection
     *
     * @returns An array containing instances of the mongoengine.cursors.Document class
     */
    fetch(limit?: number): Collection | null;
    /**
     * Ensure indexes and other required setup configuration for the collection
     * is loaded for flushing to the db
     *
     * This method is always called from init to ensure before db network action metadata is loaded
     */
    gatherMetadata(): void;
    /**
     * Return string representation of class name
     */
    getCollectionName(): string;
    json(): {
        [field: string]: any;
    };
    loadFromJson(data: {
        [field: string]: any;
    }): Collection;
    /**
     * Logical separation of AND vs OR
     */
    static OR(): typeof Collection;
    persist(): Promise<void>;
    populatePayload(payload: InsertOneWriteOpResult<any>): void;
    /**
     *
     * @param name Name of the field as passed in from closure into __mongofield__ function
     * @param options Options to use in the configuration of the field
     */
    processOptions(name: string, options: {
        [prop: string]: any;
    }): void;
    /**
     * Persist the record to the database by initialising the fields specified in the document, and
     * checking to ensure that no required fields are absent before flushing to network.
     */
    save(): Promise<void>;
    /**
     *
     * @param amount The amount of documents to skip before starting to fetch results
     */
    skip(amount: number): Collection;
}
